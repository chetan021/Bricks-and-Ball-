<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ludo Multiplayer</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }

    #container {
      width: 450px;
      display: grid;
      grid-template-columns: repeat(15, 30px);
      grid-template-rows: repeat(15, 30px);
    }

    .cell {
      height: 30px;
      width: 30px;
      border: 2px solid black;
      box-sizing: border-box;
    }

    button {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 16px;
    }

    #dice {
      margin-top: 10px;
      font-size: 20px;
    }

    .highlight {
      box-shadow: 0 0 5px 3px black;
      cursor: pointer;
    }
  </style>
</head>

<body>
  <div id="container"></div>
  <button id="rollBtn">ðŸŽ² Roll Dice</button>
  <div id="dice">ðŸŽ²</div>

  <!-- Socket.IO client -->
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script>
    const socket = io();  // assumes same origin / server serves this page

    // Room & player setup
    let roomId = prompt("Enter Room ID:");
    let isHost = confirm("Are you the host?");
    let playerColor = "";
    let maxPlayers = 4;
    let activePlayers = [];

    if (isHost) {
      maxPlayers = parseInt(prompt("How many players? (2-4)")) || 4;
      socket.emit("createRoom", { roomId, maxPlayers });
    } else {
      socket.emit("joinRoom", roomId);
    }

    socket.on("roomCreated", data => {
      playerColor = data.color;
      alert("Room created. You are " + playerColor);
    });

    socket.on("roomJoined", data => {
      playerColor = data.color;
      alert("Joined room. You are " + playerColor);
    });

    socket.on("playerJoined", ({ players }) => {
      console.log("Players now in room:", players);
    });

    socket.on("startGame", ({ players }) => {
      activePlayers = players;
      setupPlayersMap();
      drawAllTokens();
      turn = activePlayers[0];
      diceDisplay.textContent = `ðŸŽ² ${turn.toUpperCase()}'s turn`;
      rollBtn.disabled = (playerColor !== turn);
    });

    socket.on("diceRolled", ({ value, color }) => {
      diceDisplay.textContent = `ðŸŽ² ${color.toUpperCase()} rolled: ${value}`;
      rolledValue = value;
      turn = color;
      const tokens = playersMap[color];
      const anyTokenOut = tokens.some(t => t.out);
      const allTokensIn = tokens.every(t => !t.out);

      if (value !== 6 && allTokensIn) {
        rollBtn.disabled = true;
        clearHighlights();
        nextTurn();
      } else {
        if (color === playerColor) {
          rollBtn.disabled = true;
          highlightMovableTokens(rolledValue);
        } else {
          rollBtn.disabled = true;
          clearHighlights();
        }
      }

    });

    socket.on("tokenMoved", ({ index, color, tokenData }) => {
      const oldToken = playersMap[color][index];

      // Clear previous position
      if (oldToken) {
        clearCell(oldToken.row, oldToken.column);
      }

      // Update token state
      playersMap[color][index] = tokenData;

      // Draw all tokens again
      drawAllTokens();

      if (rolledValue !== 6) {
        nextTurn();
      } else if (turn === playerColor) {
        rollBtn.disabled = false;
      }
    });

    socket.on("playerLeft", () => {
      alert("A player has left. Game may be disrupted.");
    });

    socket.on("tokenReset", ({ color, index, tokenData }) => {
  // Update that player's token globally
  playersMap[color][index] = tokenData;
  clearCell(tokenData.row, tokenData.column);
  drawAllTokens();
});

    const rollBtn = document.getElementById("rollBtn");
    const diceDisplay = document.getElementById("dice");
    rollBtn.addEventListener("click", () => {
      if (playerColor === turn) {
        socket.emit("rollDice", { roomId, color: playerColor });
      }
    });

    // Board setup & Ludo logic (similar to your original, adapted for multiplayer)
    const container = document.getElementById("container");
    const ROWS = 15, COLS = 15;
    const cellColors = [];
    for (let i = 0; i < ROWS; i++) {
      cellColors[i] = [];
      for (let j = 0; j < COLS; j++) {
        const cell = document.createElement("div");
        cell.classList.add("cell");
        cell.id = `cell-${i}-${j}`;
        cellColors[i][j] = "white";
        container.appendChild(cell);
      }
    }

    function paintBlock(r1, c1, r2, c2, color, border = false) {
      for (let i = r1; i < r2; i++) {
        for (let j = c1; j < c2; j++) {
          const cell = document.getElementById(`cell-${i}-${j}`);
          cell.style.background = color;
          if (border) cell.style.borderColor = color;
          cellColors[i][j] = color;
        }
      }
    }

    // paint the board
    paintBlock(0, 0, 6, 6, "red", true);
    paintBlock(0, 9, 6, 15, "blue", true);
    paintBlock(9, 0, 15, 6, "yellow", true);
    paintBlock(9, 9, 15, 15, "green", true);
    paintBlock(7, 1, 8, 6, "red");
    paintBlock(1, 7, 6, 8, "blue");
    paintBlock(9, 7, 14, 8, "yellow");
    paintBlock(7, 9, 8, 14, "green");
    paintBlock(6, 6, 9, 9, "black", true);

    const path = [
      [6, 0], [6, 1], [6, 2], [6, 3], [6, 4], [6, 5],
      [5, 6], [4, 6], [3, 6], [2, 6], [1, 6], [0, 6],
      [0, 7], [0, 8], [1, 8], [2, 8], [3, 8], [4, 8], [5, 8],
      [6, 9], [6, 10], [6, 11], [6, 12], [6, 13], [6, 14],
      [7, 14],
      [8, 14], [8, 13], [8, 12], [8, 11], [8, 10], [8, 9],
      [9, 8], [10, 8], [11, 8], [12, 8], [13, 8], [14, 8],
      [14, 7],
      [14, 6], [13, 6], [12, 6], [11, 6], [10, 6], [9, 6],
      [8, 5], [8, 4], [8, 3], [8, 2], [8, 1], [8, 0],
      [7, 0]
    ];

    const homePaths = {
      red: [[7, 1], [7, 2], [7, 3], [7, 4], [7, 5], [7, 6]],
      blue: [[1, 7], [2, 7], [3, 7], [4, 7], [5, 7], [6, 7]],
      green: [[7, 13], [7, 12], [7, 11], [7, 10], [7, 9], [7, 8]],
      yellow: [[13, 7], [12, 7], [11, 7], [10, 7], [9, 7], [8, 7]]
    };

    const safePositions = [
      [6, 1], [1, 8], [8, 13], [13, 6],
      [2, 6], [12, 8], [8, 2], [6, 12]
    ];

    const startPositions = { red: 1, blue: 14, green: 27, yellow: 40 };

    let playersMap = {};
    let turn = "";
    let rolledValue = 0;

    function setupPlayersMap() {
      playersMap = {};
      activePlayers.forEach(color => {
        let baseRow, baseCol;
        if (color === "red") { baseRow = 1; baseCol = 1; }
        else if (color === "blue") { baseRow = 1; baseCol = 10; }
        else if (color === "yellow") { baseRow = 10; baseCol = 1; }
        else if (color === "green") { baseRow = 10; baseCol = 10; }

        playersMap[color] = createTokens(baseRow, baseCol, color);
      });
    }

    function createTokens(baseRow, baseCol, color) {
      return [
        { row: baseRow, column: baseCol, out: false, position: -1, homeIndex: -1, stepsMoved: 0, color },
        { row: baseRow, column: baseCol + 2, out: false, position: -1, homeIndex: -1, stepsMoved: 0, color },
        { row: baseRow + 2, column: baseCol, out: false, position: -1, homeIndex: -1, stepsMoved: 0, color },
        { row: baseRow + 2, column: baseCol + 2, out: false, position: -1, homeIndex: -1, stepsMoved: 0, color }
      ];
    }

    function drawToken(row, col, color) {
      const cell = document.getElementById(`cell-${row}-${col}`);
      cell.style.background = color;
      cell.style.borderRadius = "50%";
    }

    function clearCell(row, col) {
      const cell = document.getElementById(`cell-${row}-${col}`);
      cell.style.background = cellColors[row][col];
      cell.style.borderRadius = "0%";
    }

    function drawAllTokens() {
      Object.keys(playersMap).forEach(color => {
        playersMap[color].forEach(t => {
          drawToken(t.row, t.column, color);
        });
      });
    }

    function clearHighlights() {
      document.querySelectorAll(".highlight").forEach(cell => {
        cell.classList.remove("highlight");
        cell.onclick = null;
      });
    }

    safePositions.forEach(([r, c]) => {
      const cell = document.getElementById(`cell-${r}-${c}`);
      cell.innerText = "X";
      cell.style.textAlign = "center";
      cell.style.opacity = ".3";
      cell.style.border = "2px solid black";
      cell.style.boxShadow = "inset 0 0 5px 2px white";
    });

    function highlightMovableTokens(roll) {
      const tokens = playersMap[turn];
      tokens.forEach((token, index) => {
        const cell = document.getElementById(`cell-${token.row}-${token.column}`);
        cell.classList.add("highlight");
        cell.onclick = () => moveToken(index, roll);
      });
    }

    function moveToken(index, roll) {
      clearHighlights();
      const token = playersMap[turn][index];

      if (!token.out && roll === 6) {
        const startIndex = startPositions[turn];
        const [r, c] = path[startIndex];
        clearCell(token.row, token.column);
        Object.assign(token, { out: true, position: startIndex, stepsMoved: 1, row: r, column: c });
      } else if (token.out && token.homeIndex === -1) {
        const newSteps = token.stepsMoved + roll;
        if (newSteps === path.length) {
          const [r, c] = homePaths[turn][0];
          clearCell(token.row, token.column);
          Object.assign(token, { position: -1, homeIndex: 0, row: r, column: c });
        } else if (newSteps < path.length) {
          clearCell(token.row, token.column);
          token.stepsMoved = newSteps;
          token.position = (token.position + roll) % path.length;
          const [r, c] = path[token.position];
          Object.assign(token, { row: r, column: c });
          checkCollision(token);
        }
      } else if (token.homeIndex >= 0 && token.homeIndex + roll <= 5) {
        clearCell(token.row, token.column);
        token.homeIndex += roll;
        const [r, c] = homePaths[turn][token.homeIndex];
        Object.assign(token, { row: r, column: c });
      }

      // Emit the move to server
      socket.emit("tokenMoved", {
        roomId,
        index,
        color: turn,
        tokenData: token
      });

      drawAllTokens();
      checkWin(turn);

      if (roll !== 6 && token.out == false) {
        nextTurn();
        console.log("next");
      } else {
        // If rolled 6, allow same player to roll again
        if (turn === playerColor) {
          rollBtn.disabled = false;
        }
      }
    }

    function checkCollision(token) {
      const isSafe = safePositions.some(([r, c]) => r === token.row && c === token.column);
      if (isSafe) return;

      Object.keys(playersMap).forEach(color => {
        if (color === token.color) return; // don't hit your own

        playersMap[color].forEach((t, i) => {
          if (t.out && t.row === token.row && t.column === token.column) {
            clearCell(t.row, t.column);

            // Base positions per color
            let baseRow, baseCol;
            if (color === "red") { baseRow = 1; baseCol = 1; }
            else if (color === "blue") { baseRow = 1; baseCol = 10; }
            else if (color === "yellow") { baseRow = 10; baseCol = 1; }
            else if (color === "green") { baseRow = 10; baseCol = 10; }

            const newTokenPositions = [
              [baseRow, baseCol],
              [baseRow, baseCol + 2],
              [baseRow + 2, baseCol],
              [baseRow + 2, baseCol + 2],
            ];

            const [r, c] = newTokenPositions[i];

            // Reset locally
            const resetToken = {
              row: r,
              column: c,
              out: false,
              position: -1,
              homeIndex: -1,
              stepsMoved: 0,
              color,
            };
            playersMap[color][i] = resetToken;

            // ðŸ”¥ Emit reset to server so everyone updates
            socket.emit("tokenReset", {
              roomId,
              color,
              index: i,
              tokenData: resetToken
            });
          }
        });
      });

      drawAllTokens();
    }



    function checkWin(color) {
      const tokens = playersMap[color];
      if (tokens.every(t => t.homeIndex === 5)) {
        alert(`${color.toUpperCase()} wins! ðŸŽ‰`);
        rollBtn.disabled = true;
      }
    }

    function nextTurn() {
      const idx = activePlayers.indexOf(turn);
      turn = activePlayers[(idx + 1) % activePlayers.length];
      rollBtn.disabled = (playerColor !== turn);
      diceDisplay.textContent = `ðŸŽ² ${turn.toUpperCase()}'s turn`;
    }

    drawAllTokens();  // initial drawing (though no tokens until startGame)
  </script>
</body>

</html>