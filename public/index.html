<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Ludo Multiplayer</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }

    #container {
      width: 450px;
      display: grid;
      grid-template-columns: repeat(15, 30px);
      grid-template-rows: repeat(15, 30px);
    }

    .cell {
      height: 30px;
      width: 30px;
      border: 2px solid black;
      box-sizing: border-box;
    }

    button {
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 16px;
    }

    #dice {
      margin-top: 10px;
      font-size: 20px;
    }

    .highlight {
      box-shadow: 0 0 5px 3px black;
      cursor: pointer;
    }
  </style>
</head>

<body>
  <div id="container"></div>
  <button id="rollBtn">🎲 Roll Dice</button>
  <h2 id="turnDisplay">Current Turn: </h2>
  <div id="dice">🎲</div>

  <!-- Socket.IO client -->
  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script>
    const socket = io();  // assumes same origin / server serves this page

    // Room & player setup
    let roomId = prompt("Enter Room ID:");
    let isHost = confirm("Are you the host?");
    let playerColor = "";
    let maxPlayers = 4;
    let activePlayers = [];
    let playersMap = {};
    let turn = "";
    let rolledValue = 0;

    const homeEntryIndex = {
      red: 51,     // after completing full loop
      blue: 12,    // adjust based on your path layout
      green: 25,
      yellow: 38
    };

    setupPlayersMap();

    if (isHost) {
      maxPlayers = parseInt(prompt("How many players? (2-4)")) || 4;
      socket.emit("createRoom", { roomId, maxPlayers });
    } else {
      socket.emit("joinRoom", roomId);
    }

    socket.on("roomCreated", data => {
      playerColor = data.color;
      alert("Room created. You are " + playerColor);
    });

    socket.on("roomJoined", data => {
      playerColor = data.color;
      alert("Joined room. You are " + playerColor);
    });

    socket.on("playerJoined", ({ players }) => {
      console.log("Players now in room:", players);
    });

    socket.on("startGame", ({ players }) => {
      activePlayers = players;
      setupPlayersMap();
      drawAllTokens();
      turn = activePlayers[0];
      updateTurnUI();
      diceDisplay.textContent = `🎲 ${turn.toUpperCase()}'s turn`;
      rollBtn.disabled = (playerColor !== turn);
    });

    socket.on("diceRolled", ({ value, color }) => {
      diceDisplay.textContent = `🎲 ${color.toUpperCase()} rolled: ${value}`;
      rolledValue = value;
      turn = color;
      const tokens = playersMap[color];
      const anyTokenOut = tokens.some(t => t.out);
      const allTokensIn = tokens.every(t => !t.out);

      const canMove = canMoveAnyToken(color, value);
      if (!canMove) {
        rollBtn.disabled = true;
        clearHighlights();
        if (color === playerColor) {
          // alert("No possible moves. Turn skipped.");
        }
        nextTurn();
      } else {
        if (color === playerColor) {
          rollBtn.disabled = true;
          highlightMovableTokens(rolledValue);
        } else {
          rollBtn.disabled = true;
          clearHighlights();
        }
      }


    });

    socket.on("tokenMoved", ({ index, color, tokenData }) => {
      const oldToken = playersMap[color][index];

      // Clear previous position
      if (oldToken) {
        clearCell(oldToken.row, oldToken.column);
      }

      // Update token state
      playersMap[color][index] = tokenData;

      // Draw all tokens again
      drawAllTokens();

      if (rolledValue !== 6) {
        nextTurn();
      } else if (turn === playerColor) {
        rollBtn.disabled = false;
      }
    });

    socket.on("playerLeft", () => {
      alert("A player has left. Game may be disrupted.");
    });

    socket.on("tokenReset", ({ color, index, tokenData }) => {
      // Update that player's token globally
      playersMap[color][index] = tokenData;
      clearCell(tokenData.row, tokenData.column);
      drawAllTokens();
    });

    const rollBtn = document.getElementById("rollBtn");
    const diceDisplay = document.getElementById("dice");
    rollBtn.addEventListener("click", () => {
      if (playerColor === turn) {
        socket.emit("rollDice", { roomId, color: playerColor });
      }
    });

    // Board setup & Ludo logic (similar to your original, adapted for multiplayer)
    const container = document.getElementById("container");
    const ROWS = 15, COLS = 15;
    const cellColors = [];
    for (let i = 0; i < ROWS; i++) {
      cellColors[i] = [];
      for (let j = 0; j < COLS; j++) {
        const cell = document.createElement("div");
        cell.classList.add("cell");
        cell.id = `cell-${i}-${j}`;
        cellColors[i][j] = "white";
        container.appendChild(cell);
      }
    }

    function paintBlock(r1, c1, r2, c2, color, border = false) {
      for (let i = r1; i < r2; i++) {
        for (let j = c1; j < c2; j++) {
          const cell = document.getElementById(`cell-${i}-${j}`);
          cell.style.background = color;
          if (border) cell.style.borderColor = color;
          cellColors[i][j] = color;
        }
      }
    }

    function setupPlayersMap() {
      playersMap = {};
      activePlayers.forEach(color => {
        let baseRow, baseCol;
        if (color === "red") { baseRow = 1; baseCol = 1; }
        else if (color === "blue") { baseRow = 1; baseCol = 10; }
        else if (color === "yellow") { baseRow = 10; baseCol = 1; }
        else if (color === "green") { baseRow = 10; baseCol = 10; }

        playersMap[color] = createTokens(baseRow, baseCol, color);
      });
    }

    // paint the board
    paintBlock(0, 0, 6, 6, "red", true);
    paintBlock(0, 9, 6, 15, "blue", true);
    paintBlock(9, 0, 15, 6, "yellow", true);
    paintBlock(9, 9, 15, 15, "green", true);
    paintBlock(7, 1, 8, 6, "red");
    paintBlock(1, 7, 6, 8, "blue");
    paintBlock(9, 7, 14, 8, "yellow");
    paintBlock(7, 9, 8, 14, "green");
    paintBlock(6, 6, 9, 9, "black", true);

    const path = [
      [6, 0], [6, 1], [6, 2], [6, 3], [6, 4], [6, 5],
      [5, 6], [4, 6], [3, 6], [2, 6], [1, 6], [0, 6],
      [0, 7], [0, 8], [1, 8], [2, 8], [3, 8], [4, 8], [5, 8],
      [6, 9], [6, 10], [6, 11], [6, 12], [6, 13], [6, 14],
      [7, 14],
      [8, 14], [8, 13], [8, 12], [8, 11], [8, 10], [8, 9],
      [9, 8], [10, 8], [11, 8], [12, 8], [13, 8], [14, 8],
      [14, 7],
      [14, 6], [13, 6], [12, 6], [11, 6], [10, 6], [9, 6],
      [8, 5], [8, 4], [8, 3], [8, 2], [8, 1], [8, 0],
      [7, 0]
    ];

    const homePaths = {
      red: [[7, 1], [7, 2], [7, 3], [7, 4], [7, 5], [7, 6]],
      blue: [[1, 7], [2, 7], [3, 7], [4, 7], [5, 7], [6, 7]],
      green: [[7, 13], [7, 12], [7, 11], [7, 10], [7, 9], [7, 8]],
      yellow: [[13, 7], [12, 7], [11, 7], [10, 7], [9, 7], [8, 7]]
    };

    const safePositions = [
      [6, 1], [1, 8], [8, 13], [13, 6],
      [2, 6], [12, 8], [8, 2], [6, 12]
    ];

    function drawSafeCells() {
      safePositions.forEach(([r, c]) => {
        const cell = document.getElementById(`cell-${r}-${c}`);
        if (!cell) return;

        // Check if overlay already exists to prevent duplication
        if (cell.querySelector('.safe-overlay')) return;

        // Create a container for overlay (zIndex 0)
        const overlay = document.createElement("div");
        overlay.className = "safe-overlay";
        overlay.style.position = "absolute";
        overlay.style.top = "0";
        overlay.style.left = "0";
        overlay.style.width = "100%";
        overlay.style.height = "100%";
        overlay.style.background = "rgba(255, 255, 255, 0.3)";
        overlay.style.zIndex = "0"; // behind tokens
        overlay.style.border = "2px solid black";
        overlay.style.boxShadow = "inset 0 0 5px rgba(0,0,0,0.2)";
        overlay.style.pointerEvents = "none";

        // Create the safe star icon
        const star = document.createElement("div");
        star.className = "safe-star";
        star.textContent = "★";
        star.style.position = "absolute";
        star.style.top = "50%";
        star.style.left = "50%";
        star.style.transform = "translate(-50%, -50%)";
        star.style.fontWeight = "bold";
        star.style.fontSize = "18px";
        star.style.color = "rgba(0, 0, 0, 0.4)";
        star.style.zIndex = "0"; // also behind tokens
        star.style.pointerEvents = "none";

        // Append to cell
        cell.appendChild(overlay);
        cell.appendChild(star);
      });
    }



    const startPositions = { red: 1, blue: 14, green: 27, yellow: 40 };

    // Tint starting cells (entry points)
    const spawnCells = {
      red: path[startPositions.red],
      blue: path[startPositions.blue],
      yellow: path[startPositions.yellow],
      green: path[startPositions.green],
    };

    Object.entries(spawnCells).forEach(([color, [r, c]]) => {
      const cell = document.getElementById(`cell-${r}-${c}`);
      cell.style.background = color;
      cell.style.opacity = "0.5";
      cell.style.border = `2px solid ${color}`;
    });

    function createTokens(baseRow, baseCol, color) {
      return [
        { row: baseRow, column: baseCol, out: false, position: -1, homeIndex: -1, stepsMoved: 0, color },
        { row: baseRow, column: baseCol + 2, out: false, position: -1, homeIndex: -1, stepsMoved: 0, color },
        { row: baseRow + 2, column: baseCol, out: false, position: -1, homeIndex: -1, stepsMoved: 0, color },
        { row: baseRow + 2, column: baseCol + 2, out: false, position: -1, homeIndex: -1, stepsMoved: 0, color }
      ];
    }

    function drawToken(token) {
      const { row, column, color } = token;
      const cell = document.getElementById(`cell-${row}-${column}`);
      if (!cell) return;

      // Count how many tokens share this cell
      const sameCellTokens = [];
      Object.values(playersMap).forEach(tokens => {
        tokens.forEach(t => {
          if (t.row === row && t.column === column && (t.out || t.position >= 0)) {
            sameCellTokens.push(t);
          }
        });
      });

      // Remove any existing tokens in that cell container first
      cell.innerHTML = "";

      // Draw stacked or offset tokens
      sameCellTokens.forEach((t, index) => {
        const tokenEl = document.createElement("div");
        tokenEl.classList.add("token");
        tokenEl.style.background = t.color;
        tokenEl.style.border = "2px solid white";
        tokenEl.style.width = "18px";
        tokenEl.style.height = "18px";
        tokenEl.style.borderRadius = "50%";
        tokenEl.style.position = "absolute";

        // Offset pattern (circle)
        const angle = (index / sameCellTokens.length) * 2 * Math.PI;
        const offset = 8; // distance from center
        tokenEl.style.left = `${20 + offset * Math.cos(angle)}px`;
        tokenEl.style.top = `${20 + offset * Math.sin(angle)}px`;

        tokenEl.style.boxShadow = "0 0 3px black";
        cell.appendChild(tokenEl);
      });
    }


    function clearCell(row, col) {
      const cell = document.getElementById(`cell-${row}-${col}`);
      cell.style.background = cellColors[row][col];
      cell.style.borderRadius = "0%";
    }

    function updateTurnUI() {
      const turnDisplay = document.getElementById("turnDisplay");
      turnDisplay.textContent = `Current Turn: ${turn.toUpperCase()}`;
      turnDisplay.style.color = turn;
      diceDisplay.textContent = `🎲 ${turn.toUpperCase()}'s turn`;
    }

    function drawAllTokens() {
      // Clear all cells first
      for (let i = 0; i < ROWS; i++) {
        for (let j = 0; j < COLS; j++) {
          const cell = document.getElementById(`cell-${i}-${j}`);
          cell.innerHTML = "";
          cell.style.background = cellColors[i][j];
          cell.style.display = "flex";
          cell.style.alignItems = "center";
          cell.style.justifyContent = "center";
          cell.style.position = "relative";
        }
      }

      // Collect tokens per cell
      const cellTokens = {};
      Object.keys(playersMap).forEach(color => {
        playersMap[color].forEach(t => {
          const key = `${t.row}-${t.column}`;
          if (!cellTokens[key]) cellTokens[key] = [];
          cellTokens[key].push(t);
        });
      });

      // Draw tokens neatly
      Object.keys(cellTokens).forEach(key => {
        const [r, c] = key.split("-").map(Number);
        const tokens = cellTokens[key];
        const cell = document.getElementById(`cell-${r}-${c}`);

        if (tokens.length === 1) {
          const token = createTokenElement(tokens[0]);
          token.style.position = "absolute";
          token.style.top = "50%";
          token.style.left = "50%";
          token.style.transform = "translate(-50%, -50%)";
          token.style.zIndex = "5"; // ensures above safe star
          cell.appendChild(token);
        } else {
          // Arrange multiple tokens in a small circle
          const radius = 10;
          tokens.forEach((t, i) => {
            const token = createTokenElement(t);
            const angle = (i / tokens.length) * 2 * Math.PI;
            const offsetX = radius * Math.cos(angle);
            const offsetY = radius * Math.sin(angle);
            token.style.position = "absolute";
            token.style.top = `calc(50% + ${offsetY}px)`;
            token.style.left = `calc(50% + ${offsetX}px)`;
            token.style.transform = "translate(-50%, -50%)";
            token.style.zIndex = "5";
            cell.appendChild(token);
          });
        }
      });

      // Draw safe zones after tokens (but under them visually)
      drawSafeCells();
    }

    function createTokenElement(token) {
      const tokenEl = document.createElement("div");
      tokenEl.classList.add("token");
      tokenEl.style.background = token.color;
      tokenEl.style.width = "20px";
      tokenEl.style.height = "20px";
      tokenEl.style.borderRadius = "50%";
      tokenEl.style.border = "2px solid white";
      tokenEl.style.boxShadow = "0 0 3px rgba(0,0,0,0.7)";
      tokenEl.style.zIndex = "5"; // ensure visible over safe cell overlay
      return tokenEl;
    }



    function clearHighlights() {
      document.querySelectorAll(".highlight").forEach(cell => {
        cell.classList.remove("highlight");
        cell.onclick = null;
      });
    }

    // safePositions.forEach(([r, c]) => {
    //   const cell = document.getElementById(`cell-${r}-${c}`);
    //   cell.innerText = "X";
    //   cell.style.textAlign = "center";
    //   cell.style.opacity = ".3";
    //   cell.style.border = "2px solid black";
    //   cell.style.boxShadow = "inset 0 0 5px 2px white";
    // });

    function highlightMovableTokens(roll) {
      const tokens = playersMap[turn];
      tokens.forEach((token, index) => {
        const cell = document.getElementById(`cell-${token.row}-${token.column}`);
        cell.classList.add("highlight");
        cell.onclick = () => moveToken(index, roll);
      });
    }

    function canMoveAnyToken(color, roll) {
      const tokens = playersMap[color];
      const L = path.length;
      const HOME_LEN = homePaths[color].length;
      const startIdx = startPositions[color];

      for (const token of tokens) {
        // 🟢 1. Token inside base — can move only if roll === 6
        if (!token.out && roll === 6) return true;

        // 🟡 2. Token on main path
        if (token.out && token.homeIndex === -1) {
          const newSteps = token.stepsMoved + roll;
          const maxSteps = L + HOME_LEN - 1;
          if (newSteps <= maxSteps) return true; // valid move within range
        }

        // 🔵 3. Token inside home path
        if (token.homeIndex >= 0) {
          if (token.homeIndex + roll <= HOME_LEN - 1) return true;
        }
      }

      // ❌ No valid move found
      return false;
    }

    function moveToken(index, roll) {
      clearHighlights();
      const token = playersMap[turn][index];

      const L = path.length;
      const HOME_LEN = homePaths[turn].length;
      const startIdx = startPositions[turn];

      // 🟢 1. EXIT from base on a 6
      if (!token.out && roll === 6) {
        const [r, c] = path[startIdx];
        clearCell(token.row, token.column);
        Object.assign(token, {
          out: true,
          position: startIdx,
          stepsMoved: 0,
          homeIndex: -1,
          row: r,
          column: c
        });

        socket.emit("tokenMoved", { roomId, index, color: turn, tokenData: token, diceValue: roll });
        drawAllTokens();
        return;
      }

      if (token.out && token.homeIndex === -1) {
        let newSteps = token.stepsMoved + roll;
        const maxSteps = L + HOME_LEN;

        if (newSteps > maxSteps - 1) {
          console.log("Invalid move — overshoots home");
          return;
        }

        clearCell(token.row, token.column);
        token.stepsMoved = newSteps;

        if (newSteps < L) {
          // Still on main path
          const newPos = (startIdx + newSteps) % L;
          token.position = newPos;
          const [r, c] = path[newPos];
          token.row = r;
          token.column = c;
          checkCollision(token);
        } else {
          // Entering home path
          const stepsIntoHome = newSteps - L;
          token.position = -1;
          token.homeIndex = stepsIntoHome;
          const [r, c] = homePaths[turn][stepsIntoHome];
          token.row = r;
          token.column = c;
        }

        socket.emit("tokenMoved", { roomId, index, color: turn, tokenData: token, diceValue: roll });
        drawAllTokens();
        checkWin(turn);
        return;
      }


      // 🔵 3. MOVE inside home path
      if (token.homeIndex >= 0) {
        if (token.homeIndex + roll <= HOME_LEN - 1) {
          clearCell(token.row, token.column);
          token.homeIndex += roll;
          token.stepsMoved += roll;
          const [r, c] = homePaths[turn][token.homeIndex];
          token.row = r;
          token.column = c;

          socket.emit("tokenMoved", { roomId, index, color: turn, tokenData: token, diceValue: roll });
          drawAllTokens();
          checkWin(turn);
        } else {
          console.log("Cannot move inside home — overshoot");
        }
        return;
      }

      console.warn("Unhandled moveToken path");
    }



    function checkCollision(token) {
      const isSafe = safePositions.some(([r, c]) => r === token.row && c === token.column);
      if (isSafe) return;

      Object.keys(playersMap).forEach(color => {
        if (color === token.color) return; // don't hit your own

        playersMap[color].forEach((t, i) => {
          if (t.out && t.row === token.row && t.column === token.column) {
            clearCell(t.row, t.column);

            // Base positions per color
            let baseRow, baseCol;
            if (color === "red") { baseRow = 1; baseCol = 1; }
            else if (color === "blue") { baseRow = 1; baseCol = 10; }
            else if (color === "yellow") { baseRow = 10; baseCol = 1; }
            else if (color === "green") { baseRow = 10; baseCol = 10; }

            const newTokenPositions = [
              [baseRow, baseCol],
              [baseRow, baseCol + 2],
              [baseRow + 2, baseCol],
              [baseRow + 2, baseCol + 2],
            ];

            const [r, c] = newTokenPositions[i];

            // Reset locally
            const resetToken = {
              row: r,
              column: c,
              out: false,
              position: -1,
              homeIndex: -1,
              stepsMoved: 0,
              color,
            };
            playersMap[color][i] = resetToken;

            // 🔥 Emit reset to server so everyone updates
            socket.emit("tokenReset", {
              roomId,
              color,
              index: i,
              tokenData: resetToken
            });
            // Give extra roll to the killer
            rollBtn.disabled = false;
            diceDisplay.textContent = `🎯 ${token.color.toUpperCase()} got another turn for a kill!`;
          }
        });
      });

      drawAllTokens();
    }



    function checkWin(color) {
      const tokens = playersMap[color];
      if (tokens.every(t => t.homeIndex === 5)) {
        alert(`${color.toUpperCase()} wins! 🎉`);
        rollBtn.disabled = true;
      }
    }

    function nextTurn() {
      diceDisplay.textContent = `🎲 ${turn.toUpperCase()}'s turn`;
      document.getElementById("turnDisplay").style.color = turn;
      document.getElementById("turnDisplay").textContent = `Current Turn: ${turn.toUpperCase()}`;

      const idx = activePlayers.indexOf(turn);
      turn = activePlayers[(idx + 1) % activePlayers.length];
      updateTurnUI();
      rollBtn.disabled = (playerColor !== turn);
      diceDisplay.textContent = `🎲 ${turn.toUpperCase()}'s turn`;
    }

    // drawAllTokens();  // initial drawing (though no tokens until startGame)
  </script>
</body>

</html>